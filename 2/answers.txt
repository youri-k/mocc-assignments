### cpu benchmark ###

1. Wir erwarten, dass der Native Host am schnellsten durchläuft, gefolgt vom Docker-Container, da wir auf einem Linux Host System sind und dementsprechend der Linux Kernel direkt genutzt wird (ohne wirklichen Overhead).
Danach erwarten wir die Virtual Machine mit KVM, da bei der Hardware-unterstützte Virtualisierung die Anzahl der Eingriffe des Hypervisors um syscalls zu handeln entscheidend runtergeht. Am langsamsten läuft also die QEMU Instanz.

In der Qemu-VM messen wir wesentlich geringere Werte
Wir haben die höchsten Peaks tatsächlich auf dem Native Host gemessen, allerdings hat dieser über große Zeiträume bessere Performance als KVM und Docker.

messen wir echt die Zeit?

### memory benchmark ###

1. Wir erwarten, dass der Native Host am schnellsten durchläuft, gefolgt vom Docker-Container, da wir auf einem Linux Host System sind und dementsprechend der Linux Kernel direkt genutzt wird (ohne wirklichen Overhead).
Danach erwarten wir die Virtual Machine mit KVM, da bei der Hardware-unterstützte Virtualisierung die Anzahl der Eingriffe des Hypervisors um syscalls zu handeln entscheidend runtergeht. Am langsamsten läuft also die QEMU Instanz.

Unsere Erwartungen haben sich bestätigt, mit der Ausnahme, dass wir sehr überrascht darüber waren, wie viel langsamer Qemu ist, wenn es ohne KVM ausgeführt wird. Hardware-Virtualisierung ist schon ein enorm großer Performance-Boost.

### disk benchmark ###

1. Wir erwarten, dass der Native Host am schnellsten durchläuft, gefolgt vom Docker-Container, da wir auf einem Linux Host System sind und dementsprechend der Linux Kernel direkt genutzt wird (ohne wirklichen Overhead, außer um die Isolation sicherzustellen).
Danach erwarten wir die Virtual Machine mit KVM, da bei der Hardware-unterstützte Virtualisierung die Anzahl der Eingriffe des Hypervisors um syscalls zu handeln entscheidend runtergeht. Am langsamsten läuft also die QEMU Instanz.

Hier sehen wir wieder die erwartete Hierarchie von Native -> Docker -> VM (Qemu) 
Was allerdings heraussticht, ist, dass diesmal die KVM-Maschine wesentlich langsamer war (auch viel langsamer als Qemu ohne Hardware-Beschleunigung).
An dieser Stelle vermuten wir "falsche"/schlechte Konfigurationen unseres Harddisk-Devices auf der VM, in Kombination mit einer Optimierung, die auf KVM nicht zum tragen kommt.
https://serverfault.com/questions/665309/extremely-slow-disk-io-in-qemu-kvm-vm

2. Wir haben nicht explizit ein Disk Format angegeben, was bedeutet, dass Qemu per default raw für uns ausgewählt hat. 
https://unix.stackexchange.com/questions/276480/booting-a-raw-disk-image-in-qemu

### fork benchmark ###

1. Wir erwarten, dass der Native Host am schnellsten durchläuft, gefolgt vom Docker-Container, da wir auf einem Linux Host System sind und dementsprechend der Linux Kernel direkt genutzt wird (ohne wirklichen Overhead, außer um die Isolation sicherzustellen).
Danach erwarten wir die Virtual Machine mit KVM, da bei der Hardware-unterstützte Virtualisierung die Anzahl der Eingriffe des Hypervisors um syscalls zu handeln entscheidend runtergeht. Am langsamsten läuft also die QEMU Instanz.

Qemu ist erwartunsgemäß um orders of magnitude langsamer. 
Allerdings ist docker ein wenig schneller als Native und KVM ist sogar noch schneller als Docker. Wie sich dies erklären lässt (außer durch verfälschte Messwerte durch ungleiche Auslastung des Systems zu den verschiedenen Ausführungszeiten der Benchmarks) bleibt offen.